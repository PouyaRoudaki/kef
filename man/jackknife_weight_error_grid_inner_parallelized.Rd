% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jackknife_grid.R
\name{jackknife_weight_error_grid_inner_parallelized}
\alias{jackknife_weight_error_grid_inner_parallelized}
\title{Compute Jackknife Weight Errors on a Grid (Parallelized)}
\usage{
jackknife_weight_error_grid_inner_parallelized(
  centered_kernel_mat_at_sampled,
  centered_kernel_mat_at_grid,
  centered_kernel_self_grid,
  sampled_x,
  x_grid,
  lambda_hat_grid,
  tau_hat_grid,
  type_of_p_is_prob = TRUE,
  type_of_q_is_prob = TRUE,
  method_of_p_calculation = "ordinary",
  cloud_computing = FALSE
)
}
\arguments{
\item{centered_kernel_mat_at_sampled}{A numeric matrix of centered kernel values for sampled data points.}

\item{centered_kernel_mat_at_grid}{A numeric matrix of centered kernel values for the grid points.}

\item{centered_kernel_self_grid}{A numeric matrix representing the self-centered kernel values for grid points.}

\item{sampled_x}{A numeric vector of sampled data points.}

\item{x_grid}{A numeric vector of grid points.}

\item{lambda_hat_grid}{A numeric vector of lambda values for the grid.}

\item{tau_hat_grid}{A numeric vector of tau values for the grid.}

\item{type_of_p_is_prob}{Logical; if `TRUE`, `p` is interpreted as probabilities. Default is `TRUE`.}

\item{type_of_q_is_prob}{Logical; if `TRUE`, `q` is interpreted as probabilities. Default is `TRUE`.}

\item{method_of_p_calculation}{A character string specifying the method for calculating `p`. Default is "ordinary".}

\item{cloud_computing}{Logical; if `TRUE`, all available cores are used for parallelization. Default is `FALSE`.}
}
\value{
A data frame containing:
  - `lambda_hat`: The lambda values from the grid.
  - `tau_hat`: The tau values from the grid.
  - `jackknife_err`: The computed jackknife errors.
}
\description{
This function calculates jackknife weight errors for a given grid of lambda and tau values using parallelization.
}
\examples{
# Example usage:
lambda_grid <- seq(0.1, 1, by = 0.1)
tau_grid <- seq(0.1, 1, by = 0.1)
sampled_data <- rnorm(100)
grid_points <- seq(-3, 3, length.out = 50)

# Assume kernel matrices are precomputed:
centered_kernel_sampled <- matrix(runif(10000), ncol = 100)
centered_kernel_grid <- matrix(runif(5000), ncol = 50)
self_centered_grid <- matrix(runif(2500), ncol = 50)

result <- jackknife_weight_error_grid_inner_parallelized(
  centered_kernel_mat_at_sampled = centered_kernel_sampled,
  centered_kernel_mat_at_grid = centered_kernel_grid,
  centered_kernel_self_grid = self_centered_grid,
  sampled_x = sampled_data,
  x_grid = grid_points,
  lambda_hat_grid = lambda_grid,
  tau_hat_grid = tau_grid,
  cloud_computing = FALSE
)
}
