% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/centered_kernel_Rcode.R
\name{centered_kernel_matrix_R_parallel}
\alias{centered_kernel_matrix_R_parallel}
\title{Parallely Compute a Centered Kernel Matrix}
\usage{
centered_kernel_matrix_R_parallel(
  first_vec_kernel,
  second_vec_kernel,
  centering_grid,
  hurst_coef
)
}
\arguments{
\item{first_vec_kernel}{A numeric vector representing the first set of input points for the kernel computation.}

\item{second_vec_kernel}{A numeric vector representing the second set of input points for the kernel computation.}

\item{centering_grid}{A numeric vector used as the centering grid for adjusting the kernel matrix.}

\item{hurst_coef}{A numeric value (typically between 0 and 1) representing the Hurst coefficient, which determines
the scaling of the absolute differences in the kernel computations.}
}
\value{
A numeric matrix of size \code{length(first_vec_kernel) x length(second_vec_kernel)}, representing the
centered kernel matrix after all computations.
}
\description{
This function computes a centered kernel matrix using input vectors and a centering grid.
The computation involves multiple difference matrices raised to a power determined by the Hurst coefficient.
}
\examples{
# Example usage of centered_kernel_matrix_parallel
first_vec_kernel <- seq(1, 10, length.out = 100)
second_vec_kernel <- seq(1, 5, length.out = 50)
centering_grid <- seq(0, 2, length.out = 20)
hurst_coef <- 0.5

# Compute the centered kernel matrix in parallel
result <- centered_kernel_matrix_parallel(first_vec_kernel, second_vec_kernel, centering_grid, hurst_coef)
print(result)
}
